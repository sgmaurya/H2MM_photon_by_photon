% calculateTPT_from_HMM_local.m
%
% This script calculates Transition Path Times (TPTs) from existing HMM results
% generated by the "local" analysis pipeline (runHMM_local, processHMM_results_local, etc.).
% It is designed to be a direct post-processing step after runViterbi_local.m.
%
% It uses a sequential log-likelihood ratio (LLR) test on the unbinned photon
% data to identify the start (exit) and end (entry) points of transitions,
% guided by the Viterbi path from runViterbi_local.
%

function calculateTPT_from_HMM()
    clearvars -except break_debug; close all; clc;
    fprintf('--- Starting TPT Calculation from Local HMM Results ---\n');

    original_pwd = pwd;
    try
        %% 1. Select HMM Run Directory and Load All Necessary Files
        fprintf('\n--- 1. Selecting HMM Run Directory and Loading Data ---\n');
        
        project_base_path = fileparts(mfilename('fullpath'));
        results_base_path = fullfile(project_base_path, 'HMM_Local_Results');
        if ~exist(results_base_path, 'dir'), results_base_path = pwd; end
        
        selected_run_path = uigetdir(results_base_path, 'Select the HMM_Run_* directory from your local results');
        if isequal(selected_run_path, 0), disp('User cancelled. Exiting.'); return; end
        fprintf('Processing results from: %s\n', selected_run_path);
        cd(selected_run_path);

        % --- Load Best Model (Consistent with validateViterbiStates_local.m) ---
        if ~exist('Best_HMM_Model_Local.mat', 'file')
            error('TPT_ERROR: Best_HMM_Model_Local.mat not found. Please run processHMM_results_local.m first.');
        end
        fprintf('Loading Best_HMM_Model_Local.mat...\n');
        loaded_model = load('Best_HMM_Model_Local.mat', 'best_model_overall', 'config_params_to_save', 'best_idx');
        
        model_params = loaded_model.best_model_overall;
        config_params = loaded_model.config_params_to_save;
        chosen_model_idx = loaded_model.best_idx;

        % --- Load Viterbi Paths ---
        viterbi_filename = 'Viterbi_decoded_states_Q0.mat';
        if ~exist(viterbi_filename, 'file')
             error('TPT_ERROR: %s not found. Please run runViterbi_local.m first.', viterbi_filename);
        end
        fprintf('Loading %s...\n', viterbi_filename);
        load(viterbi_filename, 'Q0');

        % --- Load Raw Photon Data ---
        data_filename = 'data_re_for_hmm.mat';
        if ~exist(data_filename, 'file'), error('TPT_ERROR: %s not found.', data_filename); end
        fprintf('Loading %s...\n', data_filename);
        load(data_filename, 'data_re_for_hmm');
        data = data_re_for_hmm; 
        
        %% 2. Extract and Prepare Model Parameters
        fprintf('\n--- 2. Preparing HMM Model Parameters ---\n');
        
        Nstates = config_params.Nstates;
        if Nstates ~= 2
            error('TPT_ERROR: This script is designed for 2-state models. The loaded model has %d states.', Nstates);
        end
        
        dt_model_sec = config_params.dt_analysis_sec;
        fprintf('INFO: Extracted dt = %.2e seconds from model configuration.\n', dt_model_sec);
        
        % --- Sort states to be robust: State 1 = Low FRET, State 2 = High FRET ---
        obsmat = model_params.obsmat;
        [~, sorted_idx] = sort(obsmat(:,2)); % Sort by P(Acceptor)
        
        state_map = zeros(1, Nstates);
        state_map(sorted_idx(1)) = 1; % Low FRET state
        state_map(sorted_idx(2)) = 2; % High FRET state
        
        P_Red_L   = obsmat(sorted_idx(1), 2); P_Green_L = obsmat(sorted_idx(1), 1);
        P_Red_H   = obsmat(sorted_idx(2), 2); P_Green_H = obsmat(sorted_idx(2), 1);
        
        fprintf('State Remapping based on P(Acceptor|State):\n');
        fprintf('  - Original HMM state %d is defined as Low FRET (State 1) with P(Acceptor)=%.3f\n', sorted_idx(1), P_Red_L);
        fprintf('  - Original HMM state %d is defined as High FRET (State 2) with P(Acceptor)=%.3f\n', sorted_idx(2), P_Red_H);

        %% 3. Get User Input for LLR Algorithm
        fprintf('\n--- 3. Setting LLR Algorithm Parameters ---\n');
        ans_lambda = inputdlg({'Enter LLR Threshold (Lambda_thresh, e.g., log(100)):'}, 'LLR Parameter', [1 60], {'4.6'});
        if isempty(ans_lambda), disp('User cancelled. Exiting.'); cd(original_pwd); return; end
        lambda_thresh = str2double(ans_lambda{1});
        fprintf('INFO: LLR evidence threshold set to %.2f\n', lambda_thresh);

        %% 4. Main Loop: Iterate Through Trajectories and Transitions
        fprintf('\n--- 4. Calculating TPTs for all Transitions ---\n');
        all_TPTs_sec_HL = []; % High -> Low
        all_TPTs_sec_LH = []; % Low -> High
        
        num_trajectories = length(data);
        h_wait = waitbar(0, 'Calculating TPTs...');
        
        for i_traj = 1:num_trajectories
            waitbar(i_traj/num_trajectories, h_wait, sprintf('Trajectory %d/%d', i_traj, num_trajectories));
            
            viterbi_path_orig = Q0{i_traj};
            photon_stream = data{i_traj};
            if isempty(viterbi_path_orig) || isempty(photon_stream) || length(viterbi_path_orig) < 2
                continue;
            end
            
            % Remap Viterbi path to sorted states (1=Low, 2=High)
            viterbi_path_mapped = state_map(viterbi_path_orig);
            
            % Find indices of the first photon in the new state
            transition_indices = find(diff(viterbi_path_mapped) ~= 0) + 1;
            
            for k_trans = 1:length(transition_indices)
                idx_change = transition_indices(k_trans);
                
                state_before = viterbi_path_mapped(idx_change - 1);
                state_after  = viterbi_path_mapped(idx_change);
                
                transition_type = '';
                if state_before == 1 && state_after == 2, transition_type = 'LH'; % Low -> High
                elseif state_before == 2 && state_after == 1, transition_type = 'HL'; % High -> Low
                else, continue; end
                
                % Calculate boundaries using the LLR algorithm
                idx_exit = findExitPoint(photon_stream(:,2), idx_change, P_Red_H, P_Green_H, P_Red_L, P_Green_L, lambda_thresh, transition_type);
                idx_entry = findEntryPoint(photon_stream(:,2), idx_change, P_Red_H, P_Green_H, P_Red_L, P_Green_L, lambda_thresh, transition_type);

                % Validate and store TPT
                if ~isnan(idx_exit) && ~isnan(idx_entry) && idx_entry > idx_exit
                    time_exit_dt_units = photon_stream(idx_exit, 1);
                    time_entry_dt_units = photon_stream(idx_entry, 1);
                    
                    tpt_sec = (time_entry_dt_units - time_exit_dt_units) * dt_model_sec;
                    
                    if tpt_sec >= 0
                        if strcmp(transition_type, 'HL'), all_TPTs_sec_HL(end+1) = tpt_sec;
                        else, all_TPTs_sec_LH(end+1) = tpt_sec; end
                    end
                end
            end
        end
        if ishandle(h_wait), close(h_wait); end

        % --- START OF REVISED SECTION 5 ---

%% 5. Plotting and Saving Results (Enhanced Visualization)
fprintf('\n--- 5. Plotting and Saving TPT Results ---\n');
if isempty(all_TPTs_sec_HL) && isempty(all_TPTs_sec_LH)
    msgbox('No valid TPTs were found with the given parameters.', 'No TPTs Found', 'warn');
    cd(original_pwd);
    return;
end

% --- User choices for visualization ---
plot_style = questdlg('Choose a histogram style:', 'Plot Style', ...
                      'Overlaid (Transparent)', 'Outlines (Stairs)', 'Overlaid (Transparent)');
if isempty(plot_style), disp('Plotting cancelled.'); return; end

bin_width_ans = inputdlg('Enter bin width in microseconds (e.g., 5):', 'Bin Width', [1 40], {'5'});
if isempty(bin_width_ans), disp('Plotting cancelled.'); return; end
bin_width_us = str2double(bin_width_ans{1});
if isnan(bin_width_us) || bin_width_us <= 0, error('Invalid bin width.'); end

% --- Create Figure ---
fig_tpt_hist = figure('Name', 'TPT Distribution (Local)', 'Color', 'w', 'Position', [300, 300, 900, 600]);
ax = axes(fig_tpt_hist);
hold(ax, 'on');

% --- Calculate Stats ---
mean_tpt_us_HL = mean(all_TPTs_sec_HL) * 1e6;
mean_tpt_us_LH = mean(all_TPTs_sec_LH) * 1e6;
num_tpts_HL = length(all_TPTs_sec_HL);
num_tpts_LH = length(all_TPTs_sec_LH);

% Define colors for clarity
color_HL = [0.2 0.5 0.8]; % A nice blue
color_LH = [0.9 0.4 0.1]; % A burnt orange

% --- Plot Histograms based on chosen style ---
switch plot_style
    case 'Overlaid (Transparent)'
        if ~isempty(all_TPTs_sec_HL)
            histogram(ax, all_TPTs_sec_HL * 1e6, 'BinWidth', bin_width_us, 'Normalization', 'pdf', ...
                'FaceColor', color_HL, 'FaceAlpha', 0.6, 'EdgeColor', 'k', 'DisplayName', 'High -> Low');
        end
        if ~isempty(all_TPTs_sec_LH)
            histogram(ax, all_TPTs_sec_LH * 1e6, 'BinWidth', bin_width_us, 'Normalization', 'pdf', ...
                'FaceColor', color_LH, 'FaceAlpha', 0.6, 'EdgeColor', 'k', 'DisplayName', 'Low -> High');
        end
        
    case 'Outlines (Stairs)'
        if ~isempty(all_TPTs_sec_HL)
            histogram(ax, all_TPTs_sec_HL * 1e6, 'BinWidth', bin_width_us, 'Normalization', 'pdf', ...
                'DisplayStyle', 'stairs', 'EdgeColor', color_HL, 'LineWidth', 2.5, 'DisplayName', 'High -> Low');
        end
        if ~isempty(all_TPTs_sec_LH)
            histogram(ax, all_TPTs_sec_LH * 1e6, 'BinWidth', bin_width_us, 'Normalization', 'pdf', ...
                'DisplayStyle', 'stairs', 'EdgeColor', color_LH, 'LineWidth', 2.5, 'DisplayName', 'Low -> High');
        end
end

% --- Add vertical lines for the means ---
if ~isempty(all_TPTs_sec_HL)
    xline(ax, mean_tpt_us_HL, '--', 'Color', color_HL, 'LineWidth', 2, ...
        'DisplayName', sprintf('Mean H->L = %.2f us', mean_tpt_us_HL), 'Label', 'Mean H->L');
end
if ~isempty(all_TPTs_sec_LH)
    xline(ax, mean_tpt_us_LH, '--', 'Color', color_LH, 'LineWidth', 2, ...
        'DisplayName', sprintf('Mean L->H = %.2f us', mean_tpt_us_LH), 'Label', 'Mean L->H');
end

hold(ax, 'off');

% --- Finalize plot aesthetics ---
xlabel(ax, 'Transition Path Time (\mus)');
ylabel(ax, 'Probability Density');
grid(ax, 'on'); 
box(ax, 'on');
set(ax, 'FontSize', 11);
legend(ax, 'Location', 'NorthEast', 'FontSize', 10);

title_str1 = sprintf('TPT Distribution from LLR Analysis (Model #%d, Lambda=%.2f)', chosen_model_idx, lambda_thresh);
title_str2 = sprintf('N_{H->L} = %d | N_{L->H} = %d', num_tpts_HL, num_tpts_LH);
title(ax, {title_str1, title_str2}, 'Interpreter', 'tex'); % Use 'tex' for mu symbol

% --- Saving Results ---
fprintf('Saving TPT histogram figure and data...\n');
saveas(fig_tpt_hist, 'TPT_Distribution_LLR_Local_Enhanced.png');

save_struct.all_TPTs_sec_HL = all_TPTs_sec_HL;
save_struct.all_TPTs_sec_LH = all_TPTs_sec_LH;
save_struct.lambda_thresh = lambda_thresh;
save_struct.model_params_used.obsmat_orig = obsmat;
save_struct.model_params_used.P_Red_H = P_Red_H;
save_struct.model_params_used.P_Red_L = P_Red_L;
save_struct.chosen_model_index = chosen_model_idx;
save_struct.dt_model_sec = dt_model_sec;

save('TPT_Analysis_Results_Local.mat', '-struct', 'save_struct', '-v7.3');
fprintf('Results saved to TPT_Analysis_Results_Local.mat and Enhanced .png\n');

% --- END OF REVISED SECTION 5 ---

        fprintf('\n--- TPT Calculation Finished ---\n');
        cd(original_pwd);

    catch ME_TPT
        fprintf(2,'\nERROR in calculateTPT_from_HMM_local: %s\n', ME_TPT.message);
        disp(ME_TPT.getReport());
        if exist('h_wait', 'var') && ishandle(h_wait), close(h_wait); end
        cd(original_pwd);
    end
end

%% LLR Sub-functions
function idx_exit = findExitPoint(photon_colors, idx_change, pR_H, pG_H, pR_L, pG_L, lambda_thresh, transition_type)
    LLR = 0;
    idx_exit = NaN;
    
    if strcmp(transition_type, 'LH') % Stepping backward into initial LOW FRET state
        log_update_red   = log(pR_L / pR_H);
        log_update_green = log(pG_L / pG_H);
    else % 'HL', stepping backward into initial HIGH FRET state
        log_update_red   = log(pR_H / pR_L);
        log_update_green = log(pG_H / pG_L);
    end
    
    for i = (idx_change - 1):-1:1
        photon_color = photon_colors(i); % 1=Green(D), 2=Red(A)
        
        if photon_color == 2, LLR = LLR + log_update_red;
        else, LLR = LLR + log_update_green; end
        
        if LLR > lambda_thresh
            idx_exit = i + 1; % Exit point is the first photon AFTER the conclusive boundary
            return;
        end
    end
end

function idx_entry = findEntryPoint(photon_colors, idx_change, pR_H, pG_H, pR_L, pG_L, lambda_thresh, transition_type)
    LLR = 0;
    idx_entry = NaN;

    if strcmp(transition_type, 'LH') % Stepping forward into final HIGH FRET state
        log_update_red   = log(pR_H / pR_L);
        log_update_green = log(pG_H / pG_L);
    else % 'HL', stepping forward into final LOW FRET state
        log_update_red   = log(pR_L / pR_H);
        log_update_green = log(pG_L / pG_H);
    end

    for i = idx_change:length(photon_colors)
        photon_color = photon_colors(i);

        if photon_color == 2, LLR = LLR + log_update_red;
        else, LLR = LLR + log_update_green; end

        if LLR > lambda_thresh
            idx_entry = i; % Entry point is the first photon to cross the conclusive boundary
            return;
        end
    end
end